<!DOCTYPE html>

<html lang="zh-TW">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>PPTX 合併工具 - 文字與背景結合</title>

   

    <!-- React & ReactDOM -->

    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>

    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

   

    <!-- Babel for JSX -->

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

   

    <!-- Tailwind CSS -->

    <script src="https://cdn.tailwindcss.com"></script>

   

    <!-- Libraries for PPTX Processing -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>


    <style>

        body {

            background-color: #f3f4f6;

            font-family: 'Noto Sans TC', sans-serif;

        }

        .drop-zone {

            transition: all 0.2s ease;

        }

        .drop-zone.active {

            border-color: #3b82f6;

            background-color: #eff6ff;

        }

    </style>

</head>

<body>

    <div id="root"></div>


    <script type="text/babel">

        const { useState, useRef } = React;


        // Inline Icons components to avoid external dependency errors

        const IconUpload = () => (

            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></svg>

        );

        const IconFileText = () => (

            <svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-gray-400"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><line x1="16" x2="8" y1="13" y2="13"/><line x1="16" x2="8" y1="17" y2="17"/><line x1="10" x2="8" y1="9" y2="9"/></svg>

        );

        const IconImage = () => (

            <svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-gray-400"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></svg>

        );

        const IconArrowRight = () => (

            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-gray-300"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>

        );

        const IconCheck = () => (

            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="20 6 9 17 4 12"/></svg>

        );

        const IconDownload = () => (

            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>

        );

        const IconLoader = () => (

            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="animate-spin"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>

        );

        const IconAlert = () => (

            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/></svg>

        );

        const IconMagic = () => (

             <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-blue-600"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M9 3v4"/><path d="M3 5h4"/><path d="M3 9h4"/></svg>

        );


        const App = () => {

            const [textFile, setTextFile] = useState(null);

            const [bgFile, setBgFile] = useState(null);

            const [status, setStatus] = useState('idle'); // idle, processing, success, error

            const [logs, setLogs] = useState([]);

            const [downloadUrl, setDownloadUrl] = useState(null);


            const addLog = (msg) => {

                setLogs(prev => [...prev, msg]);

            };


            const handleFileDrop = (e, type) => {

                e.preventDefault();

                const file = e.dataTransfer.files[0];

                if (file && file.name.endsWith('.pptx')) {

                    if (type === 'text') setTextFile(file);

                    else setBgFile(file);

                } else {

                    alert('請上傳 .pptx 格式的檔案');

                }

            };


            // Helper to handle XML namespace variations

            const getSpTree = (doc) => {

                if (!doc) return null;

                // Try standard tag name

                let tree = doc.getElementsByTagName("p:spTree")[0];

                if (tree) return tree;

               

                // Try to find by localName manually if namespace prefix is different or stripped

                const all = doc.getElementsByTagName("*");

                for (let i = 0; i < all.length; i++) {

                    if (all[i].localName === "spTree") return all[i];

                }

                return null;

            };


            const processPPTX = async () => {

                if (!textFile || !bgFile) return;

               

                setStatus('processing');

                setLogs([]);

                addLog('初始化處理程序...');


                try {

                    const textZip = new JSZip();

                    const bgZip = new JSZip();


                    // 1. Load Files

                    addLog('讀取: 文字來源檔...');

                    const textContent = await textZip.loadAsync(textFile);

                   

                    addLog('讀取: 背景基底檔...');

                    const bgContent = await bgZip.loadAsync(bgFile);


                    // 2. Identify Slides

                    const textSlides = Object.keys(textContent.files).filter(path => path.match(/ppt\/slides\/slide\d+\.xml/));

                    const bgSlides = Object.keys(bgContent.files).filter(path => path.match(/ppt\/slides\/slide\d+\.xml/));


                    // Sort slides naturally

                    const sorter = (a, b) => {

                        const getNum = (str) => {

                            const match = str.match(/slide(\d+)\.xml/);

                            return match ? parseInt(match[1]) : 0;

                        };

                        return getNum(a) - getNum(b);

                    };

                    textSlides.sort(sorter);

                    bgSlides.sort(sorter);


                    addLog(`偵測: 文字檔 ${textSlides.length} 頁, 背景檔 ${bgSlides.length} 頁`);


                    const processCount = Math.min(textSlides.length, bgSlides.length);

                    const parser = new DOMParser();

                    const serializer = new XMLSerializer();


                    for (let i = 0; i < processCount; i++) {

                        const textSlidePath = textSlides[i];

                        const bgSlidePath = bgSlides[i];


                        // Read XML content

                        const textXmlStr = await textContent.file(textSlidePath).async("string");

                        const bgXmlStr = await bgContent.file(bgSlidePath).async("string");


                        const textDoc = parser.parseFromString(textXmlStr, "application/xml");

                        const bgDoc = parser.parseFromString(bgXmlStr, "application/xml");


                        // Check for parse errors

                        if (textDoc.getElementsByTagName("parsererror").length > 0) {

                            throw new Error(`解析文字檔 XML 失敗: ${textSlidePath}`);

                        }


                        const textSpTree = getSpTree(textDoc);

                        const bgSpTree = getSpTree(bgDoc);


                        if (textSpTree && bgSpTree) {

                            const textChildren = Array.from(textSpTree.childNodes);

                            let addedCount = 0;

                           

                            textChildren.forEach(node => {

                                // Robustly check node type using localName

                                const localName = node.localName || node.nodeName.split(':').pop();

                               

                                // We want Shapes (sp), Groups (grpSp), GraphicFrames (graphicFrame), Pictures (pic)

                                const allowedTags = ['sp', 'grpSp', 'graphicFrame', 'pic'];


                                if (allowedTags.includes(localName)) {

                                    try {

                                        // Import node to new document

                                        const clonedNode = bgDoc.importNode(node, true);

                                       

                                        // Simple ID collision avoidance (optional but safer)

                                        // Find cNvPr element and append a suffix to id

                                        // This is a naive implementation; proper ID management is complex

                                        // but appending a random suffix helps avoid direct clashes with BG elements

                                        const cNvPr = clonedNode.getElementsByTagName ?

                                            (clonedNode.getElementsByTagName("p:cNvPr")[0] || clonedNode.getElementsByTagName("cNvPr")[0]) : null;

                                       

                                        if (cNvPr && cNvPr.getAttribute("id")) {

                                            cNvPr.setAttribute("id", cNvPr.getAttribute("id") + "999");

                                        }


                                        bgSpTree.appendChild(clonedNode);

                                        addedCount++;

                                    } catch (e) {

                                        console.warn("Node import failed", e);

                                    }

                                }

                            });

                            addLog(`第 ${i + 1} 頁: 合併了 ${addedCount} 個物件`);

                        } else {

                            addLog(`第 ${i + 1} 頁: 找不到內容結構 (spTree)，跳過`);

                        }


                        // Save modified XML

                        const newBgXmlStr = serializer.serializeToString(bgDoc);

                        bgContent.file(bgSlidePath, newBgXmlStr);

                    }


                    // 3. Generate File

                    addLog('正在打包新檔案...');

                    const content = await bgContent.generateAsync({ type: "blob" });

                   

                    const url = URL.createObjectURL(content);

                    setDownloadUrl(url);

                    setStatus('success');

                    addLog('處理完成！');


                } catch (err) {

                    console.error(err);

                    setStatus('error');

                    addLog(`錯誤: ${err.message}`);

                }

            };


            const downloadFile = () => {

                if (downloadUrl) {

                    const a = document.createElement('a');

                    a.href = downloadUrl;

                    a.download = "merged_presentation.pptx";

                    a.click();

                }

            };


            const reset = () => {

                setTextFile(null);

                setBgFile(null);

                setStatus('idle');

                setDownloadUrl(null);

                setLogs([]);

            };


            return (

                <div className="min-h-screen py-12 px-4 sm:px-6 lg:px-8 flex flex-col items-center">

                    <div className="max-w-3xl w-full space-y-8 bg-white p-8 rounded-xl shadow-lg">

                       

                        <div className="text-center">

                            <h1 className="text-3xl font-extrabold text-gray-900 flex items-center justify-center gap-3">

                                <IconMagic />

                                PPTX 魔法合併工具

                            </h1>

                            <p className="mt-2 text-gray-500">

                                專注於將文字內容移植到背景模板

                            </p>

                        </div>


                        <div className="grid grid-cols-1 md:grid-cols-3 gap-6 items-center">

                            {/* Text Input */}

                            <FileUploader

                                file={textFile}

                                setFile={setTextFile}

                                title="1. 上傳文字檔 (無背景)"

                                icon={<IconFileText />}

                                accept=".pptx"

                                type="text"

                                onDrop={handleFileDrop}

                            />


                            <div className="flex justify-center">

                                <div className="hidden md:block transform rotate-0">

                                    <IconArrowRight />

                                </div>

                                <div className="md:hidden transform rotate-90 my-2">

                                    <IconArrowRight />

                                </div>

                            </div>


                            {/* BG Input */}

                            <FileUploader

                                file={bgFile}

                                setFile={setBgFile}

                                title="2. 上傳背景檔 (無文字)"

                                icon={<IconImage />}

                                accept=".pptx"

                                type="bg"

                                onDrop={handleFileDrop}

                            />

                        </div>


                        {/* Action Area */}

                        <div className="flex flex-col items-center justify-center space-y-4 pt-6 border-t border-gray-100">

                            {status === 'processing' && (

                                <div className="flex items-center space-x-2 text-blue-600 animate-pulse">

                                    <IconLoader />

                                    <span className="font-medium">正在解析與合併 XML...</span>

                                </div>

                            )}


                            {status === 'error' && (

                                <div className="flex items-center space-x-2 text-red-600 bg-red-50 px-4 py-2 rounded-lg">

                                    <IconAlert />

                                    <span>合併失敗，請查看日誌了解詳情。</span>

                                </div>

                            )}


                            {status === 'idle' && (

                                <button

                                    onClick={processPPTX}

                                    disabled={!textFile || !bgFile}

                                    className={`

                                        flex items-center px-8 py-3 border border-transparent text-base font-medium rounded-md shadow-sm text-white

                                        ${(!textFile || !bgFile) ? 'bg-gray-300 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500'}

                                    `}

                                >

                                    開始合併

                                </button>

                            )}


                            {status === 'success' && (

                                <div className="flex flex-col items-center space-y-4">

                                    <div className="flex items-center space-x-2 text-green-600 font-bold text-lg">

                                        <IconCheck />

                                        <span>合併成功！</span>

                                    </div>

                                    <div className="flex space-x-4">

                                        <button

                                            onClick={downloadFile}

                                            className="flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-green-600 hover:bg-green-700 shadow-lg transition-all transform hover:scale-105"

                                        >

                                            <IconDownload />

                                            <span className="ml-2">下載新檔案</span>

                                        </button>

                                        <button

                                            onClick={reset}

                                            className="flex items-center px-6 py-3 border border-gray-300 text-base font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50"

                                        >

                                            重置

                                        </button>

                                    </div>

                                </div>

                            )}

                        </div>


                        {/* Logs Console */}

                        <div className="bg-gray-900 rounded-lg p-4 font-mono text-sm h-48 overflow-y-auto shadow-inner">

                            <div className="text-gray-400 mb-2 border-b border-gray-700 pb-1">處理日誌:</div>

                            {logs.length === 0 && <span className="text-gray-600 italic">等待操作...</span>}

                            {logs.map((log, idx) => (

                                <div key={idx} className="text-green-400">> {log}</div>

                            ))}

                        </div>


                        <div className="text-xs text-gray-400 mt-4 bg-yellow-50 p-3 rounded border border-yellow-100">

                            <strong>⚠️ 使用提示：</strong>

                            <ul className="list-disc pl-5 mt-1 space-y-1">

                                <li><strong>文字移位：</strong> 合併後文字位置會保留原檔案設定，若背景設計不同，可能需要手動微調位置。</li>

                                <li><strong>字型：</strong> 若您的電腦沒有安裝原檔案使用的字型，顯示可能會有所不同。</li>

                                <li><strong>安全性：</strong> 所有操作皆在瀏覽器本地完成，檔案不會離開您的電腦。</li>

                            </ul>

                        </div>

                    </div>

                </div>

            );

        };


        const FileUploader = ({ file, setFile, title, icon, accept, type, onDrop }) => {

            const fileInputRef = useRef(null);

            const [isDragOver, setIsDragOver] = useState(false);


            const handleDragOver = (e) => {

                e.preventDefault();

                setIsDragOver(true);

            };


            const handleDragLeave = () => {

                setIsDragOver(false);

            };


            const handleDrop = (e) => {

                setIsDragOver(false);

                onDrop(e, type);

            };


            return (

                <div

                    className={`

                        relative border-2 border-dashed rounded-xl p-6 flex flex-col items-center justify-center text-center h-48 cursor-pointer drop-zone

                        ${isDragOver ? 'active border-blue-500 bg-blue-50' : 'border-gray-300 hover:border-blue-400 hover:bg-gray-50'}

                        ${file ? 'bg-blue-50 border-blue-500 border-solid' : ''}

                    `}

                    onDragOver={handleDragOver}

                    onDragLeave={handleDragLeave}

                    onDrop={handleDrop}

                    onClick={() => fileInputRef.current.click()}

                >

                    <input

                        type="file"

                        ref={fileInputRef}

                        className="hidden"

                        accept={accept}

                        onChange={(e) => setFile(e.target.files[0])}

                    />

                   

                    {file ? (

                        <div className="space-y-2">

                            <div className="w-12 h-12 bg-blue-100 text-blue-600 rounded-full flex items-center justify-center mx-auto">

                                <IconCheck />

                            </div>

                            <p className="font-medium text-gray-900 break-all line-clamp-2">{file.name}</p>

                            <p className="text-xs text-gray-500">{(file.size / 1024 / 1024).toFixed(2)} MB</p>

                        </div>

                    ) : (

                        <div className="space-y-2 pointer-events-none flex flex-col items-center">

                            {icon}

                            <h3 className="text-sm font-medium text-gray-900">{title}</h3>

                            <p className="text-xs text-gray-500">點擊或拖放檔案</p>

                        </div>

                    )}

                </div>

            );

        };


        const root = ReactDOM.createRoot(document.getElementById('root'));

        root.render(<App />);

    </script>

</body>

</html>

